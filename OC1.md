## Задание
# 1.Какой системный вызов делает команда cd?
В прошлом ДЗ вы выяснили, что cd не является самостоятельной программой. Это shell builtin, поэтому запустить strace непосредственно на cd не получится.\
Вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае увидите полный список системных вызовов, которые делает сам bash при старте.\
Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.\
ответ: chdir
# 2.Попробуйте использовать команду file на объекты разных типов в файловой системе. 
Например:
vagrant@netology1:~$ file /dev/tty
/dev/tty: character special (5/0)
vagrant@netology1:~$ file /dev/sda
/dev/sda: block special (8/0)
vagrant@netology1:~$ file /bin/bash
/bin/bash: ELF 64-bit LSB shared object, x86-64
Используя strace, выясните, где находится база данных file, на основании которой она делает свои догадки.\
![file](https://github.com/EVolgina/devops-netology10/blob/main/задание%202.PNG)
ответ: openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3 - БД будет находиться по этому пути.(/usr/share предназначена для всех файлов, которые предназначены только для чтения и не зависят от архитектуры)
# 3.Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удалён (deleted в lsof), но сказать сигналом приложению переоткрыть файлы или просто перезапустить приложение возможности нет. Так как приложение продолжает писать в удалённый файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков, предложите способ обнуления открытого удалённого файла, чтобы освободить место на файловой системе.
ответ: 
# 4.Занимают ли зомби-процессы ресурсы в ОС (CPU, RAM, IO)?
ответ: нет
# 5.В IO Visor BCC есть утилита opensnoop:
root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
/usr/sbin/opensnoop-bpfcc
На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке по ссылке.
ответ: sudo apt-get install bpfcc-tools linux-headers-$(uname -r) - установила
![file](https://github.com/EVolgina/devops-netology10/blob/main/задание%205.PNG)
# 6.Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc и где можно узнать версию ядра и релиз ОС.
![file](https://github.com/EVolgina/devops-netology10/blob/main/задание%206.PNG)
# 7.Чем отличается последовательность команд через ; и через && в bash? Например:
root@netology1:~# test -d /tmp/some_dir; echo Hi
Hi
root@netology1:~# test -d /tmp/some_dir && echo Hi
root@netology1:~#
Есть ли смысл использовать в bash &&, если применить set -e?\
ответ: Символ "; " используется для последовательного выполнения нескольких команд: после завершения одной команды начинается выполение другой.\
Если вместо"; " используется "&", то команда, сопровождаемая этим знаком, выполняется в фоновом режиме, а выполнение следующей команды начинается\ немедленно, и, таким образом, две или более команд выполняются параллельно\
& Заставляет команду работать в фоновом режиме. Из man bash: Если команда завершается оператором управления &, оболочка выполняет команду в фоновом режиме в подоболочке. Оболочка не ждет завершения команды, и статус возврата равен 0.\
Если команда завершается оператором управления ('&'), оболочка должна выполнять команду асинхронно в подоболочке. Это означает, что оболочка не должна ждать завершения команды перед выполнением следующей команды.\
Командная оболочка интерпретирует && как логическое И. При использовании этой команды вторая команда будет выполнена только после успешного выполнения первой.
set -e:Указав параметр -e скрипт немедленно завершит работу, если любая команда выйдет с ошибкой. По-умолчанию, игнорируются любые неудачи и сценарий продолжет выполнятся. Если предполагается, что команда может завершиться с ошибкой.
# 9.Из каких опций состоит режим bash set -euxo pipefail, и почему его хорошо было бы использовать в сценариях?
теория: Если нужно убедиться, что все команды в пайпах завершились успешно, нужно использовать -o pipefail,\
параметр - -u. Благодаря ему оболочка проверяет инициализацию переменных в скрипте. Если переменной не будет,\
скрипт немедленно завершиться. Данный параметр достаточно умен, чтобы нормально работать с переменной по-умолчанию\
-x очень полезен при отладке. С помощью него bash печатает в стандартный вывод все команды перед их исполнением.\

Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps изучите (/PROCESS STATE CODES), что значат дополнительные к основной заглавной букве статуса процессов. Его можно не учитывать при расчёте (считать S, Ss или Ssl равнозначными).

![file](https://github.com/EVolgina/devops-netology10/blob/main/ps%20flag.PNG)
Утилита ps может выводить состояния процессов, рассмотрим эти состояния:
D — беспробудный сон, ожидая ввод/вывод какого-нибудь устройства;
I – бездействующий поток ядра;
R — готов выполнятся или уже выполняется процессором;
S — сон, ожидает каких-нибудь ресурсов;
T — остановлен сигналом;
t — остановлен дебагом;
X — мертвый, никогда не должно быть видно;
Z — зомби, мертвый но не погребенный, то есть не успел освободить pid;
< — высокий приоритет;
N — низкий приоритет;
L — страницы процесса заблокированы в памяти;
s — лидер сессии;
l — многопоточный;
+ — выполняется на переднем плане, то есть это не фоновый процесс.
![file]()
